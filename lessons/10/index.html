<!-- 
/*
 * 
 *                  xxxxxxx      xxxxxxx
 *                   x:::::x    x:::::x 
 *                    x:::::x  x:::::x  
 *                     x:::::xx:::::x   
 *                      x::::::::::x    
 *                       x::::::::x     
 *                       x::::::::x     
 *                      x::::::::::x    
 *                     x:::::xx:::::x   
 *                    x:::::x  x:::::x  
 *                   x:::::x    x:::::x 
 *              THE xxxxxxx      xxxxxxx TOOLKIT
 *                    
 *                  http://www.goXTK.com
 *                   
 * Copyright (c) 2012 The X Toolkit Developers <dev@goXTK.com>
 *                   
 *    The X Toolkit (XTK) is licensed under the MIT License:
 *      http://www.opensource.org/licenses/mit-license.php
 *
 * LESSON 09 - Points to Spheres
 *
 * Data kindly provided by Satrajit Gosh and Arno Klein (http://www.mindboggle.info)
 * THANKS!! 
 *
 */
-->

<html>
<head>
<title>XTK LESSON 10</title>

<script type="text/javascript" src="xtk.js"></script>

<script type="text/javascript">
  
  var run = function() {
    
    // create a new renderer
    var r = new X.renderer('r');
    r.init();

    // vtk points
    var pits = new X.object();
    pits.load('../data/pits.vtk');
    
    // add the object
//    r.add(pits);
    
    // the onShowtime function gets called automatically, just before the first rendering happens
    r.onShowtime = function() {
      
      pits.setVisible(false); // hide the points

      var points = pits.points().all(); // grab the actual coordinates as a flat 1d array
      var numberOfPoints = pits.points().count(); // in this example 411
      
      // create a new sphere as a template for all other ones
      // this is an expensive operation due to CSG's mesh generation
      var newSphere = new X.sphere([points[0], points[1], points[2]], 0.7);
      newSphere.setMagicMode(true); // it's magic..
      
      // loop through the points and copy the created sphere to a new X.object
      for (var i=1; i<4; i++) {
        
        // copy the tempate sphere over to avoid generating new ones
        var copySphere = new X.object(newSphere);
        // .. and move it to the correct position
        copySphere.transform().translateX(points[i]-points[0]);
        copySphere.transform().translateY(points[i+1]-points[1]);
        copySphere.transform().translateZ(points[i+2]-points[2]);
        
        // .. add the copySphere to our container
        newSphere.merge(copySphere);
   
        window.console.log("adding sphere: " + i)     
      }
      
      // add the sphere container to the renderer
      r.add(newSphere);

      // animate!
      setInterval(function() {
        
        // rotate the camera in X-direction (which triggers re-rendering)
        r.camera().rotate([1,0]);
        
      },15);    
      
      
      
    };
    
    // .. and render it
    r.render();    
    

    
    
  };
</script>

<body onload="run()">
  
  <!-- the container for the renderer -->
  <div id="r" style="background-color: #000000; width: 100%; height: 100%;"></div>
    
</body>
